C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SPECIAL
OBJECT MODULE PLACED IN .\Output\special.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Source\special.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listing\special.lst) TABS(2) OBJECT(.\Output\special.obj)

line level    source

   1          
   2          #ifndef __SPECIAL_C__
   3          #define __SPECIAL_C__
   4          
   5          /**************************************************************************************************
   6           *                                            INCLUDES
   7           **************************************************************************************************/
   8          #include "main.h"
   9          #include "define.h"
  10          #include "type_def.h"
  11          #include "common.h"
  12          #include "special.h"
  13          
  14          /**************************************************************************************************
  15           *                                        FUNCTIONS - API
  16           **************************************************************************************************/
  17          #if (USE_SPECIAL_0F0H == TRUE)
  18          // option 0 : M708
  19          // option 1 : SAA1250
  20          // option 2 : SAA1250 BAR
  21          // option 3 : M708 CARRIER
  22          // option 4 : SAA1250 BAR2
  23          BOOL func_SPECIAL_F0(void)
  24          {
  25   1        int16u  i, j;
  26   1        ULONG   ulTemp;
  27   1        UWORD   uWord12;
  28   1      
  29   1        ramFormat.strMember.option1.flash = 1;
  30   1        uWord12 = ramFormat.strMember.word1;                            // word계산.
  31   1      
  32   1        *npWaddr_1 &= 0x7fff;
  33   1        *npWaddr_1 += ramFormat.strMember.lead[0];                      // lead
  34   1      
  35   1        uWord12 -= (*npWaddr_1)&0x7fff;
  36   1        npWaddr_1++;
  37   1      
  38   1        if(ramFormat.strMember.timeval[0] == 1)                         // saa1250
  39   1        {
  40   2          ulTemp = ramCode.Custom;                                      // system
  41   2      
  42   2          for(i=0; i<ramFormat.strMember.customsize.custom; i++)
  43   2          {
  44   3            if(ulTemp & 0x01)
  45   3            {
  46   4              *npWaddr_1 = ramFormat.strMember.logic1[0];
  47   4            }
  48   3            else
  49   3            {
  50   4              *npWaddr_1 = ramFormat.strMember.logic0[0];
  51   4            }
  52   3      
  53   3            uWord12 -= (*npWaddr_1)&0x7fff;
  54   3            npWaddr_1++;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 2   

  55   3            ulTemp >>= 1;
  56   3          }
  57   2      
  58   2          ulTemp = ramCode.Data;                                        // data
  59   2          
  60   2          for(i=0; i<ramFormat.strMember.datasize.data1; i++)
  61   2          {
  62   3            if(ulTemp&0x01)
  63   3            {
  64   4              *npWaddr_1 = ramFormat.strMember.logic1[0];
  65   4            }
  66   3            else
  67   3            {
  68   4              *npWaddr_1 = ramFormat.strMember.logic0[0];
  69   4            }
  70   3      
  71   3            uWord12 -= (*npWaddr_1)&0x7fff;
  72   3            npWaddr_1++;
  73   3            ulTemp >>= 1;
  74   3          }
  75   2        }
  76   1        else if(ramFormat.strMember.timeval[0] == 2)                        // saa1250 bar
  77   1        {
  78   2          *npWaddr_1 += ramFormat.strMember.logic0[0];                      // lead2
  79   2          uWord12 -= (*npWaddr_1)&0x7fff;
  80   2          npWaddr_1++;
  81   2      
  82   2          ulTemp = ramCode.Custom;                                      // system
  83   2          
  84   2          for(i=0; i<ramFormat.strMember.customsize.custom; i++)
  85   2          {
  86   3            if(ulTemp&0x01)
  87   3            {
  88   4              *npWaddr_1 = ramFormat.strMember.logic1[0];
  89   4            }
  90   3            else
  91   3            {
  92   4              *npWaddr_1 = ramFormat.strMember.logic0[0];
  93   4            }
  94   3      
  95   3            uWord12 -= (*npWaddr_1)&0x7fff;
  96   3            npWaddr_1++;
  97   3            ulTemp >>= 1;
  98   3          }
  99   2      
 100   2          ulTemp = ramCode.Data;                                        // data
 101   2          for(i=0;i<ramFormat.strMember.datasize.data1;i++)
 102   2          {
 103   3            if(ulTemp&0x01)
 104   3            {
 105   4              *npWaddr_1 = ramFormat.strMember.logic1[0];
 106   4            }
 107   3            else
 108   3            {
 109   4              *npWaddr_1 = ramFormat.strMember.logic0[0];
 110   4            }
 111   3      
 112   3            uWord12 -= (*npWaddr_1)&0x7fff;
 113   3            npWaddr_1++;
 114   3            ulTemp >>= 1;
 115   3          }
 116   2      
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 3   

 117   2          *npWaddr_1=ramFormat.strMember.end_pulse;              // end
 118   2          uWord12-=(*npWaddr_1)&0x7fff;
 119   2          npWaddr_1++;
 120   2      
 121   2          *npWaddr_1=uWord12;                                    // end + 5(0를 주지 않기위해)
 122   2      
 123   2          // the wait POINTER of 1'st word(word 단위)
 124   2          ir_stream.Tunion.Tstruct.bidxEndWord1 = npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 125   2          // the wait POINTER of 1'st word
 126   2          ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;
 127   2      
 128   2          npWaddr_1++;
 129   2          *npWaddr_1 += ramFormat.strMember.lead[0];                      // lead1
 130   2          ir_stream.Tunion.Tstruct.bidxRepeatWord = (npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);
 131   2      
 132   2          uWord12 -= (*npWaddr_1)&0x7fff;
 133   2          npWaddr_1++;
 134   2      
 135   2          *npWaddr_1 += ramFormat.strMember.logic0[0];                      // lead2
 136   2      
 137   2          uWord12 -= (*npWaddr_1)&0x7fff;
 138   2          npWaddr_1++;
 139   2      
 140   2          ulTemp=ramCode.Custom;                                      // system
 141   2      
 142   2          for(i=0; i<ramFormat.strMember.customsize.custom; i++)
 143   2          {
 144   3            if(ulTemp & 0x01)
 145   3            {
 146   4              *npWaddr_1 = ramFormat.strMember.logic0[0];
 147   4            }
 148   3            else
 149   3            {
 150   4              *npWaddr_1 = ramFormat.strMember.logic1[0];
 151   4            }
 152   3      
 153   3            uWord12 -= (*npWaddr_1)&0x7fff;
 154   3            npWaddr_1++;
 155   3            ulTemp >>= 1;
 156   3          }
 157   2      
 158   2          ulTemp=ramCode.Data;                                        // data
 159   2      
 160   2          for(i=0;i<ramFormat.strMember.datasize.data1;i++)
 161   2          {
 162   3            if(ulTemp&0x01)
 163   3            {
 164   4              *npWaddr_1=ramFormat.strMember.logic1[0];
 165   4            }
 166   3            else
 167   3            {
 168   4              *npWaddr_1=ramFormat.strMember.logic0[0];
 169   4            }
 170   3      
 171   3            uWord12 -= (*npWaddr_1)&0x7fff;
 172   3            npWaddr_1++;
 173   3            ulTemp >>= 1;
 174   3          }
 175   2      
 176   2          *npWaddr_1=ramFormat.strMember.end_pulse;              // end
 177   2          uWord12-=(*npWaddr_1)&0x7fff;
 178   2          npWaddr_1++;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 4   

 179   2      
 180   2          *npWaddr_1=uWord12;                                    // end + 5(0를 주지 않기위해)
 181   2      
 182   2          // the wait POINTER of 1'st word(word 단위)
 183   2          ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 184   2          // the wait POINTER of 1'st word
 185   2          ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;
 186   2      
 187   2          return TRUE;
 188   2      
 189   2        }
 190   1        else if(ramFormat.strMember.timeval[0]==4)                          // SAA1250 BAR2
 191   1        {
 192   2          *npWaddr_1+=ramFormat.strMember.logic0[0];                      // lead2
 193   2      
 194   2          uWord12-=(*npWaddr_1)&0x7fff;
 195   2          npWaddr_1++;
 196   2      
 197   2          ulTemp=ramCode.Custom;                                      // system
 198   2          for(i=0;i<ramFormat.strMember.customsize.custom;i++)
 199   2          {
 200   3            if(ulTemp&0x01)
 201   3            {
 202   4              *npWaddr_1=ramFormat.strMember.logic1[0];
 203   4            }
 204   3            else
 205   3            {
 206   4              *npWaddr_1=ramFormat.strMember.logic0[0];
 207   4            }
 208   3      
 209   3            uWord12-=(*npWaddr_1)&0x7fff;
 210   3            npWaddr_1++;
 211   3            ulTemp>>=1;
 212   3          }
 213   2      
 214   2          ulTemp=ramCode.Data;                                        // data
 215   2          for(i=0;i<ramFormat.strMember.datasize.data1;i++)
 216   2          {
 217   3            if(ulTemp&0x01)
 218   3            {
 219   4              *npWaddr_1=ramFormat.strMember.logic1[0];
 220   4            }
 221   3            else
 222   3            {
 223   4              *npWaddr_1=ramFormat.strMember.logic0[0];
 224   4            }
 225   3      
 226   3            uWord12-=(*npWaddr_1)&0x7fff;
 227   3            npWaddr_1++;
 228   3            ulTemp>>=1;
 229   3          }
 230   2      
 231   2          *npWaddr_1+=ramFormat.strMember.lead[0];                      // lead
 232   2      
 233   2          uWord12-=(*npWaddr_1)&0x7fff;
 234   2          npWaddr_1++;
 235   2      
 236   2          *npWaddr_1+=ramFormat.strMember.logic0[0];                      // lead2
 237   2      
 238   2          uWord12-=(*npWaddr_1)&0x7fff;
 239   2          npWaddr_1++;
 240   2      
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 5   

 241   2          *npWaddr_1=uWord12;                                    // end + 5(0를 주지 않기위해)
 242   2      
 243   2      
 244   2          // the wait POINTER of 1'st word(word 단위)
 245   2          ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 246   2          //ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 247   2          // the wait POINTER of 1'st word
 248   2          ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;
 249   2      
 250   2          npWaddr_1++;
 251   2      
 252   2          *npWaddr_1+=ramFormat.strMember.lead[0];                      // lead1
 253   2          //ir_stream.Tunion.Tstruct.bidxRepeatWord=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);
 254   2      
 255   2          uWord12-=(*npWaddr_1)&0x7fff;
 256   2          npWaddr_1++;
 257   2      
 258   2          *npWaddr_1+=ramFormat.strMember.logic0[0];                      // lead2
 259   2      
 260   2          uWord12-=(*npWaddr_1)&0x7fff;
 261   2          npWaddr_1++;
 262   2      
 263   2          ulTemp=ramCode.Custom;                                      // system
 264   2      
 265   2          for(i=0;i<ramFormat.strMember.customsize.custom;i++)
 266   2          {
 267   3            if(ulTemp&0x01)
 268   3            {
 269   4              *npWaddr_1=ramFormat.strMember.logic0[0];
 270   4            }
 271   3            else
 272   3            {
 273   4              *npWaddr_1=ramFormat.strMember.logic1[0];
 274   4            }
 275   3      
 276   3            uWord12-=(*npWaddr_1)&0x7fff;
 277   3            npWaddr_1++;
 278   3            ulTemp>>=1;
 279   3          }
 280   2      
 281   2          ulTemp=ramCode.Data;                                        // data
 282   2          for(i=0;i<ramFormat.strMember.datasize.data1;i++)
 283   2          {
 284   3            if(ulTemp&0x01)
 285   3            {
 286   4              *npWaddr_1=ramFormat.strMember.logic1[0];
 287   4            }
 288   3            else
 289   3            {
 290   4              *npWaddr_1=ramFormat.strMember.logic0[0];
 291   4            }
 292   3      
 293   3            uWord12-=(*npWaddr_1)&0x7fff;
 294   3            npWaddr_1++;
 295   3            ulTemp>>=1;
 296   3          }
 297   2      
 298   2          *npWaddr_1+=ramFormat.strMember.lead[0];                      // lead
 299   2      
 300   2          uWord12-=(*npWaddr_1)&0x7fff;
 301   2          npWaddr_1++;
 302   2      
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 6   

 303   2          *npWaddr_1+=ramFormat.strMember.logic0[0];                      // lead2
 304   2      
 305   2          uWord12-=(*npWaddr_1)&0x7fff;
 306   2          npWaddr_1++;
 307   2      
 308   2          *npWaddr_1=uWord12;                                    // end + 5(0를 주지 않기위해)
 309   2      
 310   2      
 311   2          // the wait POINTER of 1'st word(word 단위)
 312   2          //ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 313   2          //ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 314   2          // the wait POINTER of 1'st word
 315   2          //ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;
 316   2          ir_stream.Tunion.Tstruct.bidxEndWord2=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 317   2      
 318   2          return TRUE;
 319   2        }
 320   1        else                                            // m708, m708 carrier
 321   1        {
 322   2          j=0;
 323   2          ulTemp=ramCode.Custom;                                      // system
 324   2          for(i=0;i<ramFormat.strMember.customsize.custom;i++)
 325   2          {
 326   3            if(ulTemp&0x01)
 327   3            {
 328   4              if(j%2)
 329   4              {
 330   5                *npWaddr_1=ramFormat.strMember.logic1[0];
 331   5              }
 332   4              else
 333   4              {
 334   5                *npWaddr_1=ramFormat.strMember.logic1[2];
 335   5              }
 336   4            }
 337   3            else
 338   3            {
 339   4              *npWaddr_1=ramFormat.strMember.logic0[0];
 340   4            }
 341   3      
 342   3            uWord12-=(*npWaddr_1)&0x7fff;
 343   3            npWaddr_1++;
 344   3            ulTemp>>=1;
 345   3            j++;
 346   3          }
 347   2          ulTemp=ramCode.Data;                                        // data
 348   2          for(i=0;i<ramFormat.strMember.datasize.data1;i++)
 349   2          {
 350   3            if(ulTemp&0x01)
 351   3            {
 352   4              if(j%2)
 353   4              {
 354   5                *npWaddr_1=ramFormat.strMember.logic1[0];
 355   5              }
 356   4              else
 357   4              {
 358   5                *npWaddr_1=ramFormat.strMember.logic1[2];
 359   5              }
 360   4            }
 361   3            else
 362   3            {
 363   4              *npWaddr_1=ramFormat.strMember.logic0[0];
 364   4            }
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 7   

 365   3      
 366   3            uWord12-=(*npWaddr_1)&0x7fff;
 367   3            npWaddr_1++;
 368   3            ulTemp>>=1;
 369   3            j++;
 370   3          }
 371   2        }
 372   1      
 373   1        *npWaddr_1 = ramFormat.strMember.end_pulse;              // end
 374   1        uWord12 -= (*npWaddr_1)&0x7fff;
 375   1        npWaddr_1++;
 376   1      
 377   1        *npWaddr_1=uWord12;                                    // end + 5(0를 주지 않기위해)
 378   1      
 379   1      
 380   1        // the wait POINTER of 1'st word(word 단위)
 381   1        ir_stream.Tunion.Tstruct.bidxEndWord1 = npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 382   1        ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 383   1        // the wait POINTER of 1'st word
 384   1        ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;
 385   1      
 386   1        return TRUE;
 387   1      }
 388          #else
              BOOL  func_SPECIAL_F0(void)
              {
                return  FALSE;
              }
              #endif
 394          
 395          #if (USE_SPECIAL_0F1H == TRUE)
              // SAA1350
              BOOL func_SPECIAL_F1(void)
              {
                int     i;    //,j;
                ULONG   ulTemp;
                UWORD   uWord12;
              
                ramFormat.strMember.option1.flash=1;
                uWord12=ramFormat.strMember.word1;                          // word계산.
              
                *npWaddr_1&=0x7fff;
              
                *npWaddr_1+=ramFormat.strMember.lead[0];                      // lead
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                ulTemp=ramCode.Data;                                        // data
                for(i=0;i<ramFormat.strMember.datasize.data1;i++)
                {
                  if(ulTemp&0x01)
                  {
                    *npWaddr_1=ramFormat.strMember.logic1[0];
                  }
                  else
                  {
                    *npWaddr_1=ramFormat.strMember.logic0[0];
                  }
              
                  uWord12-=(*npWaddr_1)&0x7fff;
                  npWaddr_1++;
                  ulTemp>>=1;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 8   

                }
              
                *npWaddr_1=ramFormat.strMember.end_pulse;              // end
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                //*npWaddr_1=0x8000+100;                                        // end + 100(0를 주지 않기위해)
                //uWord12-=(*npWaddr_1)&0x7fff;
                //npWaddr_1++;
              
                *npWaddr_1=uWord12;                                           // 남은 word
              
                ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;
              
                ramFormat.strMember.outorder[0]=0xf0;
                return TRUE;
              }
              #else
 447          BOOL  func_SPECIAL_F1(void)
 448          {
 449   1        return  FALSE;
 450   1      }
 451          #endif
 452          
 453          #if (USE_SPECIAL_0F2H == TRUE)
 454          // CX7947
 455          BOOL  func_SPECIAL_F2(void)
 456          {
 457   1          int16u  i,j;
 458   1          UWORD   uWord12;
 459   1          ULONG   ulTemp;
 460   1      
 461   1          uWord12=ramFormat.strMember.word1;                          // word계산.
 462   1      
 463   1                                                                      // lead
 464   1          npWaddr_1=SetBitStreamFromNibble(npWaddr_1,&ramFormat.strMember.lead[0],3,(WORD*)&uWord12);
 465   1      
 466   1          ulTemp=ramCode.Data;                                        // data(12 or 15)
 467   1      
 468   1          if(ramCode.Data&0x8000) j=15;                               // 15 bit
 469   1          else                    j=12;                               // 12 bit
 470   1      
 471   1          for(i=0;i<j;i++)
 472   1          {
 473   2              if(ulTemp&0x01) npWaddr_1=SetBitStreamFromNibble(npWaddr_1,&ramFormat.strMember.logic1[0],3,(WORD*
             -)&uWord12);
 474   2              else            npWaddr_1=SetBitStreamFromNibble(npWaddr_1,&ramFormat.strMember.logic0[0],3,(WORD*
             -)&uWord12);
 475   2              ulTemp>>=1;
 476   2          }
 477   1          if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
 478   1          {
 479   2              if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
 480   2              *npWaddr_1=0;
 481   2          }
 482   1          //*npWaddr_1+=(uWord12+17);                                          // 남은 word
 483   1          *npWaddr_1+=(uWord12);                                          // 남은 word
 484   1      
 485   1          ir_stream.Tunion.Tstruct.bidxEndWord1=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);       
             -  // the wait POINTER of 1'st word(word 단위)
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 9   

 486   1          ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 487   1          ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // the w
             -ait POINTER of 1'st word
 488   1      
 489   1          return TRUE;
 490   1      }
 491          #else
              BOOL  func_SPECIAL_F2(void)
              {
                return  FALSE;
              }
              #endif
 497          
 498          #if (USE_SPECIAL_0F3H == TRUE)
              //SONY OLD
              BOOL  func_SPECIAL_F3(void)
              {
                  int16u  i;
                  UWORD   uWord12;
                  //UINT    xRef;
                  unsigned short  xRef;
              
                  uWord12=ramFormat.strMember.word1;                          // word계산.
              
                                                                              // lead
                  npWaddr_1=SetBitStreamFromNibble(npWaddr_1,&ramFormat.strMember.lead[0],3,(WORD*)&uWord12);
                  if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                  {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                  }
              
                  i=ramFormat.strMember.logic0[0];
                  i>>=4;
                  xRef=ramFormat.strMember.timeval[i-1];
              
                  i=ramCode.Data&0x0ff;                                       // data - 1
                  *npWaddr_1=xRef*i;
                  uWord12-=(xRef*i);
              
                                                                             // HIGH
                  npWaddr_1=SetBitStreamFromNibble(npWaddr_1,&ramFormat.strMember.logic1[0],3,(WORD*)&uWord12);
                  if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                  {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                  }
              
                  i=ramCode.Data>>8;                                          // data - 2
                  i&=0x0ff;
                  *npWaddr_1=xRef*i;
                  uWord12-=(xRef*i);
              
                  if(ramFormat.strMember.option1.non_word)
                  {
                  uWord12=ramFormat.strMember.word1;  // an interval of WAIT
                  }
                  //*npWaddr_1+=(uWord12+17);                                          // + word - non word
                  *npWaddr_1+=(uWord12);                                          // + word - non word
              
                  ir_stream.Tunion.Tstruct.bidxEndWord1=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);       
             -  // the wait POINTER of 1'st word(word 단위)
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 10  

                  ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                  ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // the w
             -ait POINTER of 1'st word
              
                  return TRUE;
              
              }
              #else
 553          BOOL  func_SPECIAL_F3(void)
 554          {
 555   1        return  FALSE;
 556   1      }
 557          #endif
 558          
 559          #if (USE_SPECIAL_0F4H == TRUE)
 560          //U327
 561          BOOL  func_SPECIAL_F4(void)
 562          {
 563   1        int     i;
 564   1        UWORD   uWord12;
 565   1        ULONG   ulTemp,ulTempPrv;
 566   1        BYTE    bBit1,bBit0;
 567   1        int     idxCarrier;
 568   1        int     first=0;
 569   1        BYTE    bBit1Carrier,bBit0Carrier;
 570   1        int     iCntBit0=0;                                         // 비교.
 571   1      
 572   1        bBit1Carrier=CARR_38400_Hz;     //38.4KHz
 573   1        bBit0Carrier=CARR_34700_Hz;   //34.7KHz
 574   1      
 575   1        ir_stream.Tunion.Tstruct.Carrier=bBit1Carrier;
 576   1      
 577   1        pramCode=(TYPE_CODE_SPECIALF4F8 *)&ir_stream;
 578   1      
 579   1        i=ramFormat.strMember.lead[0];                              // bit 1
 580   1        i>>=4;
 581   1        i&=0x7;
 582   1        bBit1=ramFormat.strMember.timeval[i-1];
 583   1      
 584   1        i=ramFormat.strMember.repeat[0];                            // bit 0
 585   1        i>>=4;
 586   1        i&=0x7;
 587   1        bBit0=ramFormat.strMember.timeval[i-1];
 588   1      
 589   1        uWord12=ramFormat.strMember.word1;                          // word계산.
 590   1      
 591   1        ulTemp=ramCode.Data;
 592   1        ulTemp&=0xff;                                               // 8bit data
 593   1      
 594   1        ulTempPrv=ramCode.Custom<<8;
 595   1        ulTempPrv&=0x1f00;                                          // 5bit custom
 596   1      
 597   1        ulTemp|=ulTempPrv;
 598   1      
 599   1        ulTempPrv=0xff;
 600   1        for(i=0;i<13;i++)                                           // total size = 13
 601   1        {
 602   2          if(ulTempPrv!=(ulTemp&0x01))
 603   2          {
 604   3            if(ulTempPrv!=0xff)
 605   3            {
 606   4              uWord12-=(*npWaddr_1)&0x7fff;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 11  

 607   4              npWaddr_1++;
 608   4            }
 609   3            *npWaddr_1=0x8000;
 610   3            first=0;
 611   3          }
 612   2          else
 613   2          {
 614   3            if(++first==1)
 615   3            {
 616   4              uWord12-=(*npWaddr_1)&0x7fff;
 617   4              npWaddr_1++;
 618   4            }
 619   3          }
 620   2      
 621   2          idxCarrier=npWaddr_1-&pramCode->Tunion.Tstruct.BitStream[0];
 622   2          if(ulTemp&0x01)
 623   2          {
 624   3            *npWaddr_1+=bBit1;
 625   3      
 626   3            pramCode->Tunion.Tstruct.bCarrierArray[idxCarrier]=bBit1Carrier;
 627   3          }
 628   2          else
 629   2          {
 630   3            *npWaddr_1+=bBit0;
 631   3      
 632   3            pramCode->Tunion.Tstruct.bCarrierArray[idxCarrier]=bBit0Carrier;
 633   3            iCntBit0+=bBit0;                                    // bit0 count
 634   3          }
 635   2          ulTempPrv=(ulTemp&0x01);
 636   2      
 637   2          ulTemp>>=1;
 638   2        }
 639   1        uWord12-=(*npWaddr_1)&0x7fff;                                 // 마지막 data고려.
 640   1      
 641   1        iCntBit0*=(bBit0-bBit1);                                    // frequency compensation
 642   1        iCntBit0/=bBit1;
 643   1        uWord12+=iCntBit0;
 644   1      
 645   1        npWaddr_1++;                                                  // 마지막은 기준 carrier적용.
 646   1        idxCarrier=npWaddr_1-&pramCode->Tunion.Tstruct.BitStream[0];
 647   1        pramCode->Tunion.Tstruct.bCarrierArray[idxCarrier]=bBit1Carrier;           // 기준.
 648   1        *npWaddr_1=uWord12;                                           // END word
 649   1      
 650   1        ir_stream.Tunion.Tstruct.bidxEndWord1=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]); // the wa
             -it POINTER of 1'st word(word 단위)
 651   1        ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 652   1        ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // the wait
             - POINTER of 1'st word
 653   1      
 654   1        //ramFormat.strMember.option1.flash=1;
 655   1          return TRUE;
 656   1      }
 657          #else
              BOOL  func_SPECIAL_F4(void)
              {
                return  FALSE;
              }
              #endif
 663          
 664          #if (USE_SPECIAL_0F5H == TRUE)
 665          //PIONEER
 666          BOOL  func_SPECIAL_F5(void)
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 12  

 667          {
 668   1          UWORD   uWord12;
 669   1          //UINT    cust,data1;
 670   1          //UINT    NormalTransport;
 671   1          ULONG    cust,data1;
 672   1          unsigned short    NormalTransport;
 673   1      
 674   1          NormalTransport=(ramCode.Data>>16)&0x00ff;
 675   1      
 676   1          cust=ramCode.Custom;
 677   1          data1=ramCode.Data;
 678   1      
 679   1        if(ramFormat.strMember.customsize.custom == 16)
 680   1        {
 681   2            ramFormat.strMember.outorder[0]=0x01;
 682   2            ramFormat.strMember.outorder[1]=0x23;
 683   2            ramFormat.strMember.outorder[2]=0x45;
 684   2            ramFormat.strMember.outorder[3]=0xff;
 685   2      
 686   2            uWord12=ramFormat.strMember.word1;                          // word계산.
 687   2      
 688   2            ramCode.Custom=(cust&0xff);
 689   2            ramCode.Data=(data1&0xff);
 690   2      
 691   2            ramFormat.strMember.customsize.custom=8;                    // size 조정 8 <- 16
 692   2            ramFormat.strMember.datasize.data1=8;
 693   2        }
 694   1        else if(ramFormat.strMember.customsize.custom == 32)
 695   1        {
 696   2            ramFormat.strMember.outorder[0]=0x01;
 697   2            ramFormat.strMember.outorder[1]=0x34;
 698   2            ramFormat.strMember.outorder[2]=0x5f;
 699   2      
 700   2            uWord12=ramFormat.strMember.word1;                          // word계산.
 701   2      
 702   2            ramCode.Custom=(cust&0xffff);
 703   2            ramCode.Data=(data1&0xff);
 704   2      
 705   2            ramFormat.strMember.customsize.custom=16;                    // size 조정 16 <- 32
 706   2            ramFormat.strMember.datasize.data1=8;
 707   2      
 708   2        }
 709   1      
 710   1          npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
 711   1          if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
 712   1          {
 713   2              if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
 714   2              *npWaddr_1=0;
 715   2          }
 716   1          //*npWaddr_1+=(uWord12+17);                                          // END 1 word
 717   1          *npWaddr_1+=(uWord12);                                          // END 1 word
 718   1      
 719   1      //  if(!(NormalTransport&1))                  // normal 1-2-1-2
 720   1        if(NormalTransport==0)                  // normal 1-2-1-2
 721   1        {
 722   2            //*npWaddr_1-=78;                                     //13.07.19 1st word adjust in 2nd word 
 723   2      
 724   2          npWaddr_1++;
 725   2          *npWaddr_1=0x8000;
 726   2      
 727   2          uWord12=ramFormat.strMember.word2;                          // word계산.
 728   2          if(ramFormat.strMember.customsize.custom == 8)
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 13  

 729   2          {
 730   3            ramCode.Custom=cust>>8;
 731   3            ramCode.Custom&=0xff;
 732   3          }
 733   2          else if(ramFormat.strMember.customsize.custom == 16)
 734   2          {
 735   3            ramCode.Custom=cust>>16;
 736   3            ramCode.Custom&=0xffff;
 737   3          }
 738   2          ramCode.Data=data1>>8;
 739   2          ramCode.Data&=0xff;
 740   2          npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
 741   2          if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
 742   2          {
 743   3                if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
 744   3            *npWaddr_1=0;
 745   3          }
 746   2          //*npWaddr_1+=(uWord12+17);                                          // END 2 word
 747   2          *npWaddr_1+=(uWord12);                                          // END 2 word
 748   2      
 749   2            ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 750   2          ir_stream.Tunion.Tstruct.bidxEndWord2=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);     // the
             - wait POINTER of 1'st word(word 단위)
 751   2            ir_stream.Tunion.Tstruct.bidxEndWord1=ir_stream.Tunion.Tstruct.bidxEndWord2;                // the wait P
             -OINTER of 1'st word(word 단위)
 752   2      
 753   2        }
 754   1      
 755   1        else if(NormalTransport==1) //1-1-1-1
 756   1        {
 757   2        //1-1-1-1
 758   2            ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 759   2          ir_stream.Tunion.Tstruct.bidxEndWord2=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);     // the
             - wait POINTER of 1'st word(word 단위)
 760   2            ir_stream.Tunion.Tstruct.bidxEndWord1=ir_stream.Tunion.Tstruct.bidxEndWord2;                // the wait P
             -OINTER of 1'st word(word 단위)
 761   2        }
 762   1      
 763   1        else if(NormalTransport==2) //2-2-2-2
 764   1        {
 765   2          npWaddr_1=(WORD*) &ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 766   2            *npWaddr_1=0x8000;
 767   2      
 768   2            uWord12=ramFormat.strMember.word1;
 769   2      
 770   2          if(ramFormat.strMember.customsize.custom == 8)
 771   2          {
 772   3            ramCode.Custom=cust>>8;
 773   3            ramCode.Custom&=0xff;
 774   3          }
 775   2          else if(ramFormat.strMember.customsize.custom == 16)
 776   2          {
 777   3            ramCode.Custom=cust>>16;
 778   3            ramCode.Custom&=0xffff;
 779   3          }
 780   2          ramCode.Data=data1>>8;
 781   2          ramCode.Data&=0xff;
 782   2          npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
 783   2          if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
 784   2          {
 785   3                if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
 786   3            *npWaddr_1=0;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 14  

 787   3          }
 788   2          //*npWaddr_1+=(uWord12+17);                 // ??                        // END 2 word
 789   2          *npWaddr_1+=(uWord12);                 // ??                        // END 2 word
 790   2      
 791   2            ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
 792   2          ir_stream.Tunion.Tstruct.bidxEndWord2=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);     // the
             - wait POINTER of 1'st word(word 단위)
 793   2            ir_stream.Tunion.Tstruct.bidxEndWord1=ir_stream.Tunion.Tstruct.bidxEndWord2;                // the wait P
             -OINTER of 1'st word(word 단위)
 794   2      
 795   2        }
 796   1      
 797   1        else if(NormalTransport==3)                 // normal 1-2-2-2
 798   1        {
 799   2          ir_stream.Tunion.Tstruct.bidxRepeatWord=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
 800   2      
 801   2            //*npWaddr_1-=78;                                     //13.07.19 1st word adjust in 2nd word 
 802   2      
 803   2          npWaddr_1++;
 804   2          *npWaddr_1=0x8000;
 805   2      
 806   2          uWord12=ramFormat.strMember.word2;                          // word계산.
 807   2          if(ramFormat.strMember.customsize.custom == 8)
 808   2          {
 809   3            ramCode.Custom=cust>>8;
 810   3            ramCode.Custom&=0xff;
 811   3          }
 812   2          else if(ramFormat.strMember.customsize.custom == 16)
 813   2          {
 814   3            ramCode.Custom=cust>>16;
 815   3            ramCode.Custom&=0xffff;
 816   3          }
 817   2          ramCode.Data=data1>>8;
 818   2          ramCode.Data&=0xff;
 819   2          npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
 820   2          if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
 821   2          {
 822   3                if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
 823   3            *npWaddr_1=0;
 824   3          }
 825   2          //*npWaddr_1+=(uWord12+17);                                          // END 2 word
 826   2          *npWaddr_1+=(uWord12);                                          // END 2 word
 827   2      
 828   2          ir_stream.Tunion.Tstruct.bidxEndWord2=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);     // the
             - wait POINTER of 1'st word(word 단위)
 829   2            ir_stream.Tunion.Tstruct.bidxEndWord1=ir_stream.Tunion.Tstruct.bidxEndWord2;                // the wait P
             -OINTER of 1'st word(word 단위)
 830   2        }
 831   1      
 832   1          ramCode.Custom=cust;
 833   1          ramCode.Data=data1;
 834   1          ramFormat.strMember.outorder[0]=0xf5;
 835   1      
 836   1          return TRUE;
 837   1      }
 838          #else
              BOOL  func_SPECIAL_F5(void)
              {
                return  FALSE;
              }
              #endif
 844          
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 15  

 845          #if (USE_SPECIAL_0F6H == TRUE)
              //ANYCARRIER
              BOOL  func_SPECIAL_F6(void)
              {
                ir_stream.Tunion.Tstruct.Carrier=(int8u)ramCode.Data;         // bCarrier
              
                *npWaddr_1=0x8000;
                *npWaddr_1+=2500;                        // High구간.
                npWaddr_1++;
              
                *npWaddr_1=ramFormat.strMember.word2;                         // low 구간.
              
                ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        // t
             -he wait POINTER of 1'st word(word 단위)
                ir_stream.Tunion.Tstruct.bidxEndWord1--;                                     // HIGH 구간만.
                ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;  // the wait POINTER of 1'st
             - word
              
                return TRUE;
              }
              #else
 865          BOOL  func_SPECIAL_F6(void)
 866          {
 867   1        return  FALSE;
 868   1      }
 869          #endif
 870          
 871          #if (USE_SPECIAL_0F7H == TRUE)
              void  func_SPECIAL_F7_Fill_Logic(void)
              {
                int16u  data1;
                int8u i;
                int8u BitData;
              
                data1=(int16u)ramCode.Data;
              
                for(i=0; i<16; i++)
                {
                  BitData=(int8u)(data1&0x01);
                  data1>>=1;
              
                  if(i%2)                           //low envelop   (1,3,5,...)
                  {
                    if(BitData)                     //bit 1
                      *npWaddr_1=(ramFormat.strMember.logic1[0]);
                    else                            //bit 0
                      *npWaddr_1=(ramFormat.strMember.logic0[0]);
                  }
                  else                              //high envelop  (0,2,4,...)
                  {
                    if(BitData)                     //bit 1
                      *npWaddr_1=(ramFormat.strMember.logic1[0]+0x8000);
                    else                            //bit 0
                      *npWaddr_1=(ramFormat.strMember.logic0[0]+0x8000);
                  }
                  npWaddr_1++;
                }
              }
              
              //PANSONIC ZAP
              BOOL func_SPECIAL_F7(void)
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 16  

              {
                //lead
                *npWaddr_1=(ramFormat.strMember.lead[0]+0x8000);
                npWaddr_1++;
                *npWaddr_1=ramFormat.strMember.lead[1];
                npWaddr_1++;
              
                //1'st frame
                func_SPECIAL_F7_Fill_Logic();
              
                //end stream
                *npWaddr_1=(ramFormat.strMember.end_pulse+0x8000);
                npWaddr_1++;
                *npWaddr_1=ramFormat.strMember.word1;
                ir_stream.Tunion.Tstruct.bidxEndWord1=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);
              
                npWaddr_1++;
                ir_stream.Tunion.Tstruct.bidxRepeatWord=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);
              
                //lead
                *npWaddr_1=(ramFormat.strMember.lead[2]+0x8000);
                npWaddr_1++;
                *npWaddr_1=ramFormat.strMember.lead[1];
                npWaddr_1++;
              
                //2'nd frame
                func_SPECIAL_F7_Fill_Logic();
              
                //end stream
                *npWaddr_1=(ramFormat.strMember.end_pulse+0x8000);
                npWaddr_1++;
              
                *npWaddr_1=ramFormat.strMember.word2;
                ir_stream.Tunion.Tstruct.bidxEndWord2=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);
              
                return TRUE;
              }
              #else
 943          BOOL  func_SPECIAL_F7(void)
 944          {
 945   1        return  FALSE;
 946   1      }
 947          #endif
 948          
 949          #if (USE_SPECIAL_0F8H == TRUE)
              //two carrier
              BOOL func_SPECIAL_F8(void)
              {
                  UWORD uWord12;
                  ULONG ulIndex;
              
                  ulIndex=ramCode.Data;
                  ulIndex>>=(ramFormat.strMember.datasize.data1-8);
                ramFormat.strMember.datasize.data1 = ulIndex;
              
                  ramFormat.strMember.outorder[0]=0x13;                       // S() +D()
              
                  uWord12=ramFormat.strMember.word1;                          // word계산.
              
                  npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                  if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 17  

                  {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                  }
              
                uWord12=ramFormat.strMember.word1;
                *npWaddr_1+=uWord12;
              
                  ir_stream.Tunion.Tstruct.bidxEndWord1=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);       
             -  // the wait POINTER of 1'st word(word 단위)
                  ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                  ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // the w
             -ait POINTER of 1'st word
              
                ramFormat.strMember.option1.flash=1;
                ramFormat.strMember.outorder[0]=0xf8;
              
                return  TRUE;
              }
              #else
 985          BOOL func_SPECIAL_F8(void)
 986          {
 987   1        return  FALSE;
 988   1      }
 989          #endif
 990          
 991          #if (USE_SPECIAL_0F9H == TRUE)
              //ONKYO FORMAT(MUTICUSTOM & REPEAT,CONTINUOUS)
              BOOL func_SPECIAL_F9(void)
              {
                UWORD   uWord12;
                ULONG   ulIndex;
              
                ulIndex=ramCode.Data;
                ulIndex>>=ramFormat.strMember.datasize.data1;
                ulIndex&=(ULONG)pbMaskIndex[ramFormat.strMember.datasize.index1+ramFormat.strMember.customsize.index2-1];
              
                ramFormat.strMember.outorder[2]=0xff;
              
                uWord12=ramFormat.strMember.word1;                          // word계산.
              
                ramFormat.strMember.outorder[0]=0x01;                       // L + S(8) +D(24) + E
                ramFormat.strMember.outorder[1]=0x35;
              
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                }
                *npWaddr_1+=uWord12;                                          // END 1 word
              
                ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        // t
             -he wait POINTER of 1'st word(word 단위)
              
                if(ulIndex==0)                                              // repeat pulse
                {
                  npWaddr_1++;
                  *npWaddr_1=0x8000;
              
                  ir_stream.Tunion.Tstruct.bidxRepeatWord=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 18  

                  uWord12=ramFormat.strMember.word2;                          // word계산.
              
                  ramFormat.strMember.outorder[0]=0xaf;                   // A
                  npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                  if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                  {
                    if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                    *npWaddr_1=0;
                  }
                  *npWaddr_1+=uWord12;                                          // END 2 word
              
                  ir_stream.Tunion.Tstruct.bidxEndWord2=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                }
                else
                {
                  ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                  ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // the wai
             -t POINTER of 1'st word
                }
              
                ramFormat.strMember.outorder[0]=0xf9;
              
                return TRUE;
              }
              #else
1050          BOOL  func_SPECIAL_F9(void)
1051          {
1052   1        return  FALSE;
1053   1      }
1054          #endif
1055          
1056          #if (USE_SPECIAL_0FAH == TRUE)
              //nec 1word - 2word - repeat
              BOOL func_SPECIAL_FA(void)
              {
                UWORD uWord12;
              
                ramFormat.strMember.outorder[0]=0x01;                       // L + S(32) + E
                ramFormat.strMember.outorder[1]=0x5f;
              
                uWord12=ramFormat.strMember.word1;                          // word계산.
              
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                }
                *npWaddr_1+=uWord12;                                          // END 0.5 word
              
                npWaddr_1++;
                *npWaddr_1=0x8000;
              
                uWord12=ramFormat.strMember.word2;                          // word계산.
                ramFormat.strMember.outorder[0]=0x03;                       // L + D(32) + E
                ramFormat.strMember.outorder[1]=0x5f;
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 19  

                }
                *npWaddr_1+=uWord12;                                          // END 1 word
              
                ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        // t
             -he wait POINTER of 1'st word(word 단위)
              
                npWaddr_1++;
                *npWaddr_1=0x8000;
              
                ir_stream.Tunion.Tstruct.bidxRepeatWord=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
              
                uWord12=ramFormat.strMember.word2;                          // word계산.
                ramFormat.strMember.outorder[0]=0x0af;                      // R
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                }
                *npWaddr_1+=uWord12;                                          // END 2 word
              
                ir_stream.Tunion.Tstruct.bidxEndWord2=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        // t
             -he wait POINTER of 2'nd word
              
                ramFormat.strMember.outorder[0]=0xfa;
              
                return TRUE;
              }
              #else
1114          BOOL  func_SPECIAL_FA(void)
1115          {
1116   1        return  FALSE;
1117   1      }
1118          #endif
1119          
1120          #if (USE_SPECIAL_0FBH == TRUE)
              //nec repeat & continue
              BOOL func_SPECIAL_FB(void)
              {
                  UWORD uWord12;
                  ULONG ulIndex;
              
                  ulIndex=ramCode.Data;
                  ulIndex>>=ramFormat.strMember.datasize.data1;
                  ulIndex&=(ULONG)pbMaskIndex[ramFormat.strMember.datasize.index1+ramFormat.strMember.customsize.index2-
             -1];
              
                  ramFormat.strMember.outorder[0]=0x01;                       // L + S(16) +D(16) + E
                  ramFormat.strMember.outorder[1]=0x35;
                  ramFormat.strMember.outorder[2]=0xff;
              
                  uWord12=ramFormat.strMember.word1;                          // word계산.
              
                  npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                  if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                  {
                      if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                      *npWaddr_1=0;
                  }
                  *npWaddr_1+=uWord12;                                          // END 1 word
              
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 20  

                  ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        /
             -/ the wait POINTER of 1'st word(word 단위)
              
                  if(ulIndex==0)                                              // repeat pulse
                  {
                      npWaddr_1++;
                      *npWaddr_1=0x8000;
              
                      ir_stream.Tunion.Tstruct.bidxRepeatWord=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                      uWord12=ramFormat.strMember.word2;                          // word계산.
              
                      ramFormat.strMember.outorder[0]=0xaf;                   // A
                      npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                      if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                      {
                          if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                          *npWaddr_1=0;
                      }
                      *npWaddr_1+=uWord12;                                          // END 2 word
              
                      ir_stream.Tunion.Tstruct.bidxEndWord2=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                  }
                  else
                  {
                      ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                      ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // t
             -he wait POINTER of 1'st word
                  }
              
                  ramFormat.strMember.outorder[0]=0xfb;
              
                  return TRUE;
              }
              #else
1178          BOOL  func_SPECIAL_FB(void)
1179          {
1180   1        return  FALSE;
1181   1      }
1182          #endif
1183          
1184          #if (USE_SPECIAL_0FCH == TRUE)
              //PATTERN112_ 1word - 1word - repeat
              BOOL func_SPECIAL_FC(void)
              {
                UWORD   uWord12;
              
                ramFormat.strMember.outorder[0]=0x03;                       // L + D(24) + E
                ramFormat.strMember.outorder[1]=0x5f;
              
                uWord12=ramFormat.strMember.word1;                          // word계산.
              
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                }
                *npWaddr_1+=uWord12;                                          // END 0.5 word
              
                npWaddr_1++;
                *npWaddr_1=0x8000;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 21  

              
                uWord12=ramFormat.strMember.word2;                          // word계산.
                                                                            // L + D(24) + E
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                }
                *npWaddr_1+=uWord12;                                          // END 1 word
              
                ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        // t
             -he wait POINTER of 1'st word(word 단위)
              
                npWaddr_1++;
                *npWaddr_1=0x8000;
              
                ir_stream.Tunion.Tstruct.bidxRepeatWord=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
              
                uWord12=ramFormat.strMember.word2;                          // word계산.
                ramFormat.strMember.outorder[0]=0xaf;                      // R
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                  *npWaddr_1=0;
                }
                *npWaddr_1+=uWord12;                                          // END 1 word
              
                ir_stream.Tunion.Tstruct.bidxEndWord2=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        // t
             -he wait POINTER of 2'nd word
              
                ramFormat.strMember.outorder[0]=0xfc;
              
                return TRUE;
              }
              #else
1241          BOOL  func_SPECIAL_FC(void)
1242          {
1243   1        return  FALSE;
1244   1      }
1245          #endif
1246          
1247          #if (USE_SPECIAL_0FDH == TRUE)
              //nec repeat & continue
              //16A(L + D + D_bar + C + C') REPEAT & CONTINUOUS
              BOOL func_SPECIAL_FD(void)
              {
                  UWORD uWord12;
                  ULONG ulIndex;
              
                  ulIndex=ramCode.Data;
                  ulIndex>>=ramFormat.strMember.datasize.data1;
                  ulIndex&=(ULONG)pbMaskIndex[ramFormat.strMember.datasize.index1+ramFormat.strMember.customsize.index2-
             -1];
              
                  ramFormat.strMember.outorder[0]=0x03;                       // L + S(16) +D(16) + E
                  ramFormat.strMember.outorder[1]=0x41;
                  ramFormat.strMember.outorder[2]=0x5f;
              
                  uWord12=ramFormat.strMember.word1;                          // word계산.
              
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 22  

                  npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                  if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                  {
                      if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                      *npWaddr_1=0;
                  }
                  *npWaddr_1+=uWord12;                                          // END 1 word
              
                  ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];        /
             -/ the wait POINTER of 1'st word(word 단위)
              
                  if(ulIndex==0)                                              // repeat pulse
                  {
                      npWaddr_1++;
                      *npWaddr_1=0x8000;
              
                      ir_stream.Tunion.Tstruct.bidxRepeatWord=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                      uWord12=ramFormat.strMember.word2;                          // word계산.
              
                      ramFormat.strMember.outorder[0]=0xaf;                   // A
                      npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                      if(*npWaddr_1&0x8000)                                         // Ending the 1'st Word
                      {
                          if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
                          *npWaddr_1=0;
                      }
                      *npWaddr_1+=uWord12;                                          // END 2 word
              
                      ir_stream.Tunion.Tstruct.bidxEndWord2=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                  }
                  else
                  {
                      ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                      ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // t
             -he wait POINTER of 1'st word
                  }
              
                  ramFormat.strMember.outorder[0]=0xfd;
              
                  return TRUE;
              }
              #else
1306          BOOL  func_SPECIAL_FD(void)
1307          {
1308   1        return  FALSE;
1309   1      }
1310          #endif
1311          
1312          #if (USE_SPECIAL_0FEH_3 == TRUE)
              //Metz Three low..
              BOOL func_SPECIAL_E3(void)
              {
                int16u      i;
                unsigned long ulTemp;
                unsigned short  uWord12;
              
                //Order : L + S + D + E
                uWord12=ramFormat.strMember.word1;                            // word계산.
                //LEAD
                *npWaddr_1+=ramFormat.strMember.end_pulse;                // high
                uWord12-=(*npWaddr_1)&0x7fff;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 23  

                npWaddr_1++;
              
                *npWaddr_1=ramFormat.strMember.lead[0];                       // lead
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                *npWaddr_1+=0x8000+ramFormat.strMember.end_pulse;               // high
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                *npWaddr_1=ramFormat.strMember.lead[1];                       // lead
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                *npWaddr_1+=0x8000+ramFormat.strMember.end_pulse;               // high
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                *npWaddr_1=ramFormat.strMember.lead[2];                       // lead
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                //CUSTOM
                ulTemp=ramCode.Custom;
                for(i=0;i<ramFormat.strMember.customsize.custom;i+=2)
                {
                  *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;          // high
                  uWord12-=(*npWaddr_1)&0x7fff;
                  npWaddr_1++;
              
              #if 0
                  *npWaddr_1=ramFormat.strMember.timeval[1+(ulTemp&0x03)];    //Three Low
              #else
                  switch(ulTemp&0x03)
                  {
                    case  0:
                      *npWaddr_1=ramFormat.strMember.timeval[1];    //Three Low
                      break;
                    case  1:
                      *npWaddr_1=ramFormat.strMember.timeval[3];    //Three Low
                      break;
                    case  2:
                      *npWaddr_1=ramFormat.strMember.timeval[2];    //Three Low
                      break;
                    case  3:
                      *npWaddr_1=ramFormat.strMember.timeval[4];    //Three Low
                      break;
                  }
              #endif
              
                  uWord12-=(*npWaddr_1)&0x7fff;
                  npWaddr_1++;
                  ulTemp>>=2;
                }
              
                //DATA
                ulTemp=ramCode.Data;                                          // data
              
              #if 1
                switch(ramFormat.strMember.timeval[0])          //option
                {
                  case  0:                      //no toggle
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 24  

                    break;
                  case  1:                      //2ea toggle
                    ulTemp=ulTemp&(ULONG)~0xf0000000;
                    switch(gl_Toggle[curr_source]&0x01)
                    {
                      case  0:
                        ulTemp=ulTemp|0x80000000;
                        break;
                      case  1:
                        ulTemp=ulTemp|0xd0000000;
                        break;
                    }
                    break;
                  case  2:                      //4ea toggle
                    ulTemp=ulTemp&(ULONG)~0xff000000;
                    switch(gl_Toggle[curr_source]&0x03)
                    {
                      case  0:
                        ulTemp=ulTemp|0x88000000;
                        break;
                      case  1:
                        ulTemp=ulTemp|0xdd000000;
                        break;
                      case  2:
                        ulTemp=ulTemp|0x8d000000;
                        break;
                      case  3:
                        ulTemp=ulTemp|0xd8000000;
                        break;
                    }
                    break;
                  case  3:                      //4ea toggle
                    ulTemp=ulTemp&(ULONG)~0xff000000;
                    switch(gl_Toggle[curr_source]&0x03)
                    {
                      case  0:
                        ulTemp=ulTemp|0x44000000;
                        break;
                      case  1:
                        ulTemp=ulTemp|0xee000000;
                        break;
                      case  2:
                        ulTemp=ulTemp|0x4e000000;
                        break;
                      case  3:
                        ulTemp=ulTemp|0xe4000000;
                        break;
                    }
                    break;
                }
              #endif
              
                for(i=0;i<ramFormat.strMember.datasize.data1;i+=2)
                {
                  *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;          // high
                  uWord12-=(*npWaddr_1)&0x7fff;
                  npWaddr_1++;
              
              #if 0
                  *npWaddr_1=ramFormat.strMember.timeval[1+(ulTemp&0x03)];    //Three Low
              #else
                  switch(ulTemp&0x03)
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 25  

                  {
                    case  0:
                      *npWaddr_1=ramFormat.strMember.timeval[1];    //Three Low
                      break;
                    case  1:
                      *npWaddr_1=ramFormat.strMember.timeval[3];    //Three Low
                      break;
                    case  2:
                      *npWaddr_1=ramFormat.strMember.timeval[2];    //Three Low
                      break;
                    case  3:
                      *npWaddr_1=ramFormat.strMember.timeval[4];    //Three Low
                      break;
                  }
              #endif
              
                  uWord12-=(*npWaddr_1)&0x7fff;
                  npWaddr_1++;
                  ulTemp>>=2;
                }
                //end..
                *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;            // high
                uWord12-=(*npWaddr_1)&0x7fff;
                npWaddr_1++;
              
                *npWaddr_1+=uWord12;                                          // END 1 word
              
                ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]; // the wait
             - POint16uER of 1'st word(word 단위)
                ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // the wait
             - POint16uER of 1'st word
              
                return TRUE;
              }
              
              #else
1484          
1485          BOOL func_SPECIAL_E3()
1486          {
1487   1        return FALSE;
1488   1      }
1489          
1490          #endif
1491          
1492          
1493          #if (USE_SPECIAL_0FEH_4 == TRUE)
              WORD* func_SPECIAL_BnO_SubBitStream(int16u data1, int8u size, int8u type)
              {
                int8u prev_bit=0xff;
                int8u i;
              
                if(type)                                                  //data
                {
                  int16u  cust=(int16u)ramCode.Custom;
              
                  cust>>=9;
                  if(cust&0x01)
                    prev_bit=1;
                  else
                    prev_bit=0;
                }
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 26  

              
                for(i=0; i<size; i++)
                {
                  if(data1&0x01)
                  {
                    *npWaddr_1++=(ramFormat.strMember.end_pulse+0x8000);  //high 30us
              
                    if(prev_bit==1)                                       //same bit
                    {
                      *npWaddr_1=ramFormat.strMember.repeat[0];
                      *npWaddr_1<<=8;
                      *npWaddr_1|=ramFormat.strMember.repeat[1];
                    }
                    else
                    {
                      *npWaddr_1=ramFormat.strMember.logic1[0];
                      *npWaddr_1<<=8;
                      *npWaddr_1|=ramFormat.strMember.logic1[1];
                    }
                    npWaddr_1++;
                    prev_bit=1;
                  }
                  else
                  {
                    *npWaddr_1++=(ramFormat.strMember.end_pulse+0x8000);  //high 30us
              
                    if(!prev_bit)                                         //same bit
                    {
                      *npWaddr_1=ramFormat.strMember.repeat[0];
                      *npWaddr_1<<=8;
                      *npWaddr_1|=ramFormat.strMember.repeat[1];
                    }
                    else
                    {
                      *npWaddr_1=ramFormat.strMember.logic0[0];
                      *npWaddr_1<<=8;
                      *npWaddr_1|=ramFormat.strMember.logic0[1];
                    }
                    npWaddr_1++;
                    prev_bit=0;
                  }
                  data1>>=1;
                }
                return  npWaddr_1;
              }
              
              WORD* func_Special_BnO_1stFrameFillStream()
              {
                int16u  data1;
              
                *npWaddr_1++=(ramFormat.strMember.end_pulse+0x8000);      //high 30us
                *npWaddr_1=ramFormat.strMember.logic0[0];
                *npWaddr_1<<=8;
                *npWaddr_1|=ramFormat.strMember.logic0[1];                //lead 1'st 3ms
                npWaddr_1++;
              
                *npWaddr_1++=(ramFormat.strMember.end_pulse+0x8000);      //high 30us
                *npWaddr_1=ramFormat.strMember.logic0[0];
                *npWaddr_1<<=8;
                *npWaddr_1|=ramFormat.strMember.logic0[1];                //lead 2'nd 3ms
                npWaddr_1++;
              
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 27  

                *npWaddr_1++=(ramFormat.strMember.end_pulse+0x8000);      //high 30us
                *npWaddr_1=ramFormat.strMember.lead[0];
                *npWaddr_1<<=8;
                *npWaddr_1|=ramFormat.strMember.lead[1];                  //lead 3'rd 15.4ms
                npWaddr_1++;
              
                data1=(int16u)ramCode.Custom;                             //custom 9bit
                npWaddr_1=func_SPECIAL_BnO_SubBitStream(data1, 9, 0);
              
                data1=(int16u)ramCode.Data;                               //data 8bit
                npWaddr_1=func_SPECIAL_BnO_SubBitStream(data1, 8, 1);
              
                *npWaddr_1++=(ramFormat.strMember.end_pulse+0x8000);      //high 30us
                *npWaddr_1=ramFormat.strMember.timeval[0];
                *npWaddr_1<<=8;
                *npWaddr_1|=ramFormat.strMember.timeval[1];               //end bit 12.4ms
                npWaddr_1++;
              
                *npWaddr_1++=(ramFormat.strMember.end_pulse+0x8000);      //high 30us
              
                return  npWaddr_1;
              }
              
              //Bang & Olufsen 455KHz
              BOOL func_SPECIAL_E4()
              {
                int16u  data1;
              
                npWaddr_1=func_Special_BnO_1stFrameFillStream();
              
                data1=(int16u)ramCode.Data;
                data1>>=8;
              
                if(data1&0xff)                                    //index 1 -> continous ~~
                {
                  *npWaddr_1++=ramFormat.strMember.word1;       //1'st end
                  *npWaddr_1++=ramFormat.strMember.word1;       //1'st end
                  *npWaddr_1=ramFormat.strMember.word2;         //1'st end
              
                  ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
              
                  npWaddr_1++;
                  ir_stream.Tunion.Tstruct.bidxRepeatWord=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
              
                  npWaddr_1=func_Special_BnO_1stFrameFillStream();
                  npWaddr_1--;
              
                  npWaddr_1--;    //add 2012
              
                  ir_stream.Tunion.Tstruct.bidxEndWord2=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                }
                else                                            //index 0 -> single 1frame
                {
                  *npWaddr_1++=ramFormat.strMember.word1;       //1'st end (0x7fff)
                  *npWaddr_1++=ramFormat.strMember.word1;       //1'st end (0x7fff)
                  *npWaddr_1=ramFormat.strMember.word2;         //1'st end (0x451e)
              
                  ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                  ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;
                  ir_stream.Tunion.Tstruct.bidxRepeatWord=ir_stream.Tunion.Tstruct.bidxEndWord1;
                }
                return TRUE;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 28  

              }
              
              #else
1636          
1637          BOOL func_SPECIAL_E4()
1638          {
1639   1        return FALSE;
1640   1      }
1641          #endif
1642          
1643          
1644          #if (USE_SPECIAL_0FEH_5 == TRUE)
1645          //Three low..
1646          BOOL func_SPECIAL_E5(void)
1647          {
1648   1        int16u      i;
1649   1        unsigned long ulTemp;
1650   1        unsigned short  uWord12;
1651   1      
1652   1        Three_low_keyoff=0;
1653   1      
1654   1        //Order : L + S + D + E
1655   1        uWord12=ramFormat.strMember.word1;                            // word계산.
1656   1        //LEAD
1657   1        *npWaddr_1+=ramFormat.strMember.lead[0]+1;                    // high
1658   1        uWord12-=(*npWaddr_1)&0x7fff;
1659   1        npWaddr_1++;
1660   1      
1661   1        *npWaddr_1=ramFormat.strMember.lead[1];                       // lead
1662   1        uWord12-=(*npWaddr_1)&0x7fff;
1663   1        npWaddr_1++;
1664   1      
1665   1      #if 0
                if((!key_cnt)&&(ramFormat.strMember.timeval[0]==0))
                {
                    ramCode.Custom=(ramCode.Custom|0x00650000);
                }
              #endif
1671   1      
1672   1        //CUSTOM
1673   1        ulTemp=ramCode.Custom;
1674   1        for(i=0;i<ramFormat.strMember.customsize.custom;i+=2)
1675   1        {
1676   2          *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;          // high
1677   2          uWord12-=(*npWaddr_1)&0x7fff;
1678   2          npWaddr_1++;
1679   2      
1680   2      #if 0
                  *npWaddr_1=ramFormat.strMember.timeval[1+(ulTemp&0x03)];    //Three Low
              #else
1683   2          switch(ulTemp&0x03)
1684   2          {
1685   3            case  0:
1686   3              *npWaddr_1=ramFormat.strMember.timeval[1];    //Three Low
1687   3              break;
1688   3            case  1:
1689   3              *npWaddr_1=ramFormat.strMember.timeval[3];    //Three Low
1690   3              break;
1691   3            case  2:
1692   3              *npWaddr_1=ramFormat.strMember.timeval[2];    //Three Low
1693   3              break;
1694   3            case  3:
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 29  

1695   3              *npWaddr_1=ramFormat.strMember.timeval[4];    //Three Low
1696   3              break;
1697   3          }
1698   2      #endif
1699   2      
1700   2          uWord12-=(*npWaddr_1)&0x7fff;
1701   2          npWaddr_1++;
1702   2          ulTemp>>=2;
1703   2        }
1704   1      
1705   1      #if 0
                switch(ramFormat.strMember.timeval[0])          //option
                {
                  case  0:
                    Three_low_keyoff=1;
                    break;
                  case  1:
                    *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;          // high
                    uWord12-=(*npWaddr_1)&0x7fff;
                    npWaddr_1++;
              
                    switch(gl_Toggle[curr_source]&0x01)
                    {
                      case  0:
                        *npWaddr_1=ramFormat.strMember.timeval[1];    //Three Low
                        break;
                      case  1:
                        *npWaddr_1=ramFormat.strMember.timeval[3];    //Three Low
                        break;
                    }
                    npWaddr_1++;
                    break;
                  case  2:
                    *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;          // high
                    uWord12-=(*npWaddr_1)&0x7fff;
                    npWaddr_1++;
              
                    switch(gl_Toggle[curr_source]&0x03)
                    {
                      case  0:
                        *npWaddr_1=ramFormat.strMember.timeval[1];    //Three Low
                        break;
                      case  1:
                        *npWaddr_1=ramFormat.strMember.timeval[3];    //Three Low
                        break;
                      case  2:
                        *npWaddr_1=ramFormat.strMember.timeval[2];    //Three Low
                        break;
                      case  3:
                        *npWaddr_1=ramFormat.strMember.timeval[4];    //Three Low
                        break;
                    }
                    npWaddr_1++;
                    break;
                }
              
                DATA
                ulTemp=ramCode.Data;                                          // data
              
              #else
1755   1        //DATA
1756   1        ulTemp=ramCode.Data;                                          // data
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 30  

1757   1      
1758   1        switch(ramFormat.strMember.timeval[0])          //option
1759   1        {
1760   2          case  0:                      //key off toggle
1761   2            if(!key_cnt)
1762   2            {
1763   3              switch(ulTemp&0x01)
1764   3              {
1765   4                case  0:
1766   4                  ulTemp=ulTemp|0x01;
1767   4                  break;
1768   4                case  1:
1769   4                  ulTemp=ulTemp&~0x01;
1770   4                  break;
1771   4              }
1772   3              //for(i=0;i<3000;i++) wait_10us();
1773   3            }
1774   2            else
1775   2              Three_low_keyoff=1;
1776   2            break;
1777   2          case  1:                      //2ea toggle
1778   2            if(gl_Toggle[curr_source]&0x01)
1779   2            {
1780   3              switch(ulTemp&0x01)
1781   3              {
1782   4                case  0:
1783   4                  ulTemp=ulTemp|0x01;
1784   4                  break;
1785   4                case  1:
1786   4                  ulTemp=ulTemp&~0x01;
1787   4                  break;
1788   4              }
1789   3            }
1790   2            break;
1791   2          case  2:                      //4ea toggle
1792   2            ulTemp=ulTemp&~0x03;
1793   2            switch(gl_Toggle[curr_source]&0x03)
1794   2            {
1795   3              case  0:
1796   3                break;
1797   3              case  1:
1798   3                ulTemp=ulTemp|0x01;
1799   3                break;
1800   3              case  2:
1801   3                ulTemp=ulTemp|0x02;
1802   3                break;
1803   3              case  3:
1804   3                ulTemp=ulTemp|0x03;
1805   3                break;
1806   3            }
1807   2            break;
1808   2          case  3:                      //no toggle
1809   2            break;
1810   2        }
1811   1      
1812   1      #endif
1813   1      
1814   1        for(i=0;i<ramFormat.strMember.datasize.data1;i+=2)
1815   1        {
1816   2          *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;          // high
1817   2          uWord12-=(*npWaddr_1)&0x7fff;
1818   2          npWaddr_1++;
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 31  

1819   2      
1820   2      #if 0
                  *npWaddr_1=ramFormat.strMember.timeval[1+(ulTemp&0x03)];    //Three Low
              #else
1823   2          switch(ulTemp&0x03)
1824   2          {
1825   3            case  0:
1826   3              *npWaddr_1=ramFormat.strMember.timeval[1];    //Three Low
1827   3              break;
1828   3            case  1:
1829   3              *npWaddr_1=ramFormat.strMember.timeval[3];    //Three Low
1830   3              break;
1831   3            case  2:
1832   3              *npWaddr_1=ramFormat.strMember.timeval[2];    //Three Low
1833   3              break;
1834   3            case  3:
1835   3              *npWaddr_1=ramFormat.strMember.timeval[4];    //Three Low
1836   3              break;
1837   3          }
1838   2      #endif
1839   2      
1840   2          uWord12-=(*npWaddr_1)&0x7fff;
1841   2          npWaddr_1++;
1842   2          ulTemp>>=2;
1843   2        }
1844   1        //end..
1845   1        *npWaddr_1=0x8000+ramFormat.strMember.end_pulse+1;            // high
1846   1        uWord12-=(*npWaddr_1)&0x7fff;
1847   1        npWaddr_1++;
1848   1      
1849   1        *npWaddr_1+=uWord12;                                          // END 1 word
1850   1      
1851   1        ir_stream.Tunion.Tstruct.bidxEndWord1=npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]; // the wait
             - POint16uER of 1'st word(word 단위)
1852   1        ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
1853   1        ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;                  // the wait
             - POint16uER of 1'st word
1854   1      
1855   1        return TRUE;
1856   1      }
1857          
1858          #else
              
              BOOL func_SPECIAL_E5()
              {
                return FALSE;
              }
              #endif
1865          
1866          
1867          #if (USE_SPECIAL_0FEH_8 == TRUE)
              #if 0
              //하위 4bit return
              int8u func_SPECIAL_E8_CHKSUM(ULONG *  pudata)
              {
                //ULONG *   pu=0;
                int8u   i,j;
                int8u   sum;
              
                //pu = pdata;
                sum = 0;
              
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 32  

                for(i = 0 ; i < 6 ; i++)
                {
                  j = (int8u)((ULONG)(*pudata>>(i*4)) & 0x0000000f);
                  sum += (int8u)j;
                }
              
                sum =(int8u)(~sum);   //subtract 256
              
                sum &=0x0f;   //16 mod
              
                return sum;
              
              }
              #endif
              
              enum SPECIAL_FORMAT_E8_POINT_TAG
              {
                FMT_HIGH_PT =0,
                FMT_LOW0_PT =1,
                FMT_LOW1_PT =2,
                FMT_LOW2_PT =3,
                FMT_LOW3_PT =4,
                FMT_LOW4_PT =5,
                FMT_LOW5_PT =6,
                FMT_LOW6_PT =7,
                FMT_LOW7_PT =8,
                FMT_LOW8_PT =9,
                FMT_LOW9_PT =10,
                FMT_LOW10_PT =11,
                FMT_LOW11_PT =12,
                FMT_LOW12_PT =13,
                FMT_LOW13_PT =14,
                FMT_LOW14_PT =15,
                FMT_LOW15_PT =16,
                FMT_CUST_PAUSE_PT =17,
                FMT_WORD1_PT =18,
                FMT_WORD2_PT =20
              } SPECIAL_FORMAT_E8_POINT;
              
              
              
              //format : XMP-1 -2010. 7. 6.
              BOOL func_SPECIAL_E8()
              {
                //int8u   repeat_f=0;
                int8u *   pfmt;
                int8u   i;
                int8u   j;
                WORD    w_cal_wordtime;
                //ULONG   utmp;
                WORD *    pStart1;
                WORD *    pEnd1;
                WORD *    pStart2;
                WORD *    pEnd2;
                WORD *    p;
              
                //convert LSB first
                Convert_cd(&ramCode.Data);
                Convert_cd(&ramCode.Custom);
              
              #if 0
                //set repeat_F
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 33  

                j = (int8u)(ramCode.Data>>28 & 0x0f);
                if(j == 0xf)
                {
                  ramCode.Data &= ~0xF0000000;
                  ramCode.Data |= 0x10000000;
                  repeat_f = 1;
                }
                else
                {
                  ramCode.Data &= ~0xF0000000;
                  ramCode.Data |= 0x10000000;
                  repeat_f = 0;
                }
              #endif
              
                //load carrier
                ir_stream.Tunion.Tstruct.Carrier = (WORD)ramCode.bCarrier;
              
                //init point.
                pStart1 = &ir_stream.Tunion.Tstruct.pulse.BitStream[0];
                p=npWaddr_1;
              
                //load custom bitstream
                //pfmt = (byte*)&ramFormat.strMember.outorder[0];
                pfmt = (byte*)&ramFormat.strMember.logic1[0];
                for(i = 0 ; i < 8 ; i++)
                {
                  *p = pfmt[FMT_HIGH_PT];
                  *p +=  0x8000;  //high
                  p++;
              
                  j = (ramCode.Custom>>(28 - (4*i))) & 0x0F;      //상위 4bit low.
                  *p=((WORD)pfmt[FMT_LOW0_PT + j]);
                  p++;
                }
              
                //end bit
                *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                p++;
              
                //load custom pause
                //p--;
              
              #if 0
                *p = ((WORD)pfmt[FMT_CUST_PAUSE_PT] + 400); //pause time : 12.897ms, 38khz.
              #else
                *p = ((WORD)pfmt[FMT_CUST_PAUSE_PT]*5); //pause time : 12.897ms, 38khz.
              #endif
                p++;
              
                //load data bitstream
                for(i = 0 ; i < 8 ; i++)
                {
                  *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                  p++;
              
                  j = (ramCode.Data>>(28 - (4*i))) & 0x0F;      //상위 4bit low.
                  *p=((WORD)pfmt[FMT_LOW0_PT + j]);
                  p++;
                }
              
                //end bit
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 34  

                *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                p++;
              
                //calculate end_word time.
                //pw = (WORD*)pfmt[FMT_WORD1_PT];
                //w_cal_wordtime = *pw;   //1word
                w_cal_wordtime = ramFormat.strMember.word1;
              
                j = p-pStart1;
              
                for(i = 0 ; i < j ; i++)
                {
                  w_cal_wordtime -= (pStart1[i]&0x7fff) ;
              
                }
                //p--;
                *p = w_cal_wordtime;
                p++;
              
              #if 0
                if(repeat_f == 0)
                {
                  ir_stream.Tunion.Tstruct.bidxEndWord1 = p-pStart1-1;
                  ir_stream.Tunion.Tstruct.bidxEndWord2 = p-pStart1-1;
                  ir_stream.Tunion.Tstruct.bidxRepeatWord = p-pStart1-1;
                  *p=0;
                  return TRUE ;
                }
              #endif
              
              //2dn word
                pStart2 = p;
                pEnd1 = p-1;
              
                //load custom bitstream
                for(i = 0 ; i < 8 ; i++)
                {
                  *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                  p++;
              
                  j = (ramCode.Custom>>(28-(i*4)))&0x0F;      //상위 4bit low.
                  *p=((WORD)pfmt[FMT_LOW0_PT + j]);
                  p++;
              
                }
              
                //end bit
                *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                p++;
              
                //custom pause
                //p--;
              #if 0
                *p = ((WORD)pfmt[FMT_CUST_PAUSE_PT] + 400); //pause time : 12.897ms, 38khz.
              #else
                *p = ((WORD)pfmt[FMT_CUST_PAUSE_PT]*5); //pause time : 12.897ms, 38khz.
              #endif
                p++;
              
              #if 0
                //load data bitstream
                for(i = 0 ; i < 8 ; i++)
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 35  

                {
                  if(i != 1 && i !=2)
                  {
                    *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                    p++;
              
                    j = (ramCode.Data>>(28-(i*4))) & 0x0F;      //상위 4bit low.
                    *p=((WORD)pfmt[FMT_LOW0_PT + j]);
                    p++;
              
                  }
                  else if(i == 1)   //checksum.
                  {
                    *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                    p++;
              
                    //세번째 nibble 8입력.
                    ramCode.Data &=~0x00f00000;
                    ramCode.Data |=0x00800000;
                    j = func_SPECIAL_E8_CHKSUM((ULONG *)&ramCode.Data); //상위 4bit low.
              
                    //두번째 nibble checksum입력.
                    ramCode.Data &=~0x0f000000;
                    utmp = (ULONG)j;
                    ramCode.Data |=utmp<<24;
              
                    *p=((WORD)pfmt[FMT_LOW0_PT + j]);
                    p++;
                  }
                  else if(i == 2)   //toggle
                  {
                    *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                    p++;
              
                    j = 8;      //toggle 8.
                    *p=((WORD)pfmt[FMT_LOW0_PT + j]);
                    p++;
                  }
              
                }
              #else
                //ramCode.Data = ramCode.Data;
                if(ramCode.Data&0x00800000)
                  ramCode.Data &=~0x00800000;
                else
                  ramCode.Data |=0x00800000;
                if(ramCode.Data&0x08000000)
                  ramCode.Data &=~0x08000000;
                else
                  ramCode.Data |=0x08000000;
              
                //load data bitstream
                for(i = 0 ; i < 8 ; i++)
                {
                  *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                  p++;
              
                  j = (ramCode.Data>>(28 - (4*i))) & 0x0F;      //상위 4bit low.
                  *p=((WORD)pfmt[FMT_LOW0_PT + j]);
                  p++;
                }
              
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 36  

              #endif
              
                //end bit
                *p=((WORD)pfmt[FMT_HIGH_PT]+0x8000);  //high
                p++;
              
                //calculate end_word time.
                //pw = (WORD*)pfmt[FMT_WORD2_PT];
                //w_cal_wordtime = *pw;   //1word
                w_cal_wordtime = ramFormat.strMember.word2;
              
                j = p-pStart2;
              
                for(i = 0 ; i < j ; i++)
                {
                  w_cal_wordtime -= (pStart2[i]&0x7fff) ;
                }
                //p--;
              
                *p = w_cal_wordtime;
              
                pEnd2 = p;
              
                ir_stream.Tunion.Tstruct.bidxEndWord1 = pEnd1-pStart1;
                ir_stream.Tunion.Tstruct.bidxEndWord2 = pEnd2-pStart1;
                ir_stream.Tunion.Tstruct.bidxRepeatWord = pStart2-pStart1;
                p++;
                *p=0;
              
              
                return TRUE;
              }
              
              #else
2161          
2162          BOOL func_SPECIAL_E8()
2163          {
2164   1        return FALSE;
2165   1      }
2166          #endif
2167          
2168          
2169          #if (USE_SPECIAL_0FEH_9 == TRUE)
              //Canal toggle
              // 1st frame : S(14) + Logic1 + D(8)
              // next frame : S(14) + Logic0 + D(8)
              BOOL func_SPECIAL_E9()
              {
                unsigned short  uWord12;
              
                  ramFormat.strMember.outorder[0]=0x18;                       // 1st frame : S(14) + Logic1 + D(8)
                  ramFormat.strMember.outorder[1]=0x3f;
              
                uWord12=ramFormat.strMember.word1;                                // word계산.
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                if(*npWaddr_1&0x8000)                                             // Ending the 1'st Word
                {
                  if(++npWaddr_1 >= (WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM] )
                    npWaddr_1--;
                  *npWaddr_1=0;
                }
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 37  

              
                *npWaddr_1+=uWord12;
                ir_stream.Tunion.Tstruct.bidxEndWord1=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);         /
             -/ the wait POINTER of 1'st word(word 단위)
              
                if(ramFormat.strMember.option1.repeat)
                {
                    ramFormat.strMember.outorder[0]=0x19;                       // next frame : S(14) + Logic0 + D(8)
                    ramFormat.strMember.outorder[1]=0x3f;
              
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM]) npWaddr_1--;
              
                  *npWaddr_1=0x8000;                                              // repeat start //!!! 반드시 처음 puls
             -e는 HIGH부터 !!!///
                  ir_stream.Tunion.Tstruct.bidxRepeatWord=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);  // th
             -e wait POINTER of 1'st word
              
                  uWord12=ramFormat.strMember.word2;                              // word계산.
                  npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
              
                  if(*npWaddr_1&0x8000)                                           // Ending the 2'nd Word
                  {
                    if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM])
                      npWaddr_1--;
                    *npWaddr_1=0;
                  }
                  *npWaddr_1+=uWord12;
                  ir_stream.Tunion.Tstruct.bidxEndWord2=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);
                }
                else
                {
                  ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                  ir_stream.Tunion.Tstruct.bidxEndWord2=ir_stream.Tunion.Tstruct.bidxEndWord1;              // the wait PO
             -INTER of 1'st word
                }
              
                return TRUE;
              }
              
              #else
2225          
2226          BOOL func_SPECIAL_E9()
2227          {
2228   1        return FALSE;
2229   1      }
2230          #endif
2231          
2232          #if (USE_SPECIAL_0FEH_A == TRUE)
              //AMINO_AROSA
              int16u  func_SPECIAL_EA(void)
              {
                  UWORD   uWord12;
                  unsigned short    cust,data1,data2;
              
                  cust=ramCode.Custom;
                  data1=ramCode.Data;
                  data2=ramCode.Data;
                data2&=0xff00;
              
                  ramFormat.strMember.outorder[0]=0x01;
                  ramFormat.strMember.outorder[1]=0x3f;
              
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 38  

                  uWord12=ramFormat.strMember.word1;                          // word계산.
              
                  ramFormat.strMember.customsize.custom=16;                    //
                  ramFormat.strMember.datasize.data1=16;
              
                  npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                if(*npWaddr_1&0x8000)         // Ending the 2'nd Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM])
                    npWaddr_1--;
                  *npWaddr_1=0;
                }
                  *npWaddr_1+=(uWord12);                                          // END 1 word
              
                npWaddr_1++;
                *npWaddr_1=0x8000;
              
                ir_stream.Tunion.Tstruct.bidxRepeatWord=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);
              
                uWord12=ramFormat.strMember.word2;                          // word계산.
                ramCode.Custom=cust;
                ramCode.Custom|=0x0020;
              
                ramCode.Data=data1;
              
                switch(data2)
                {
                  case  0x0000:
                  case  0x1000:
                  case  0x4000:
                  case  0x5000:
                  case  0x8000:
                  case  0x9000:
                  case  0xc000:
                  case  0xd000:
                    ramCode.Data|=0x2000;
                    break;
                  case  0x3000:
                  case  0x7000:
                  case  0xb000:
                  case  0xf000:
                    ramCode.Data&=~0x3000;
                    break;
                  case  0x2000:
                  case  0x6000:
                  case  0xa000:
                  case  0xe000:
                    ramCode.Data&=~0x2000;
                    ramCode.Data|=0x1000;
                    break;
                  default:  
                    break;
                }
              
              
                npWaddr_1=FillBitStreamFromOutOrder(0,(WORD*)npWaddr_1,(WORD*)&uWord12);
                if(*npWaddr_1&0x8000)         // Ending the 2'nd Word
                {
                  if(++npWaddr_1>=(WORD*)&ir_stream.Tunion.Tstruct.pulse.BitStream[MAX_BITSTREAM])
                    npWaddr_1--;
                  *npWaddr_1=0;
                }
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 39  

                *npWaddr_1+=(uWord12);                                          // END 2 word
              
                  //ir_stream.Tunion.Tstruct.bidxRepeatWord=0;
                ir_stream.Tunion.Tstruct.bidxEndWord2=(npWaddr_1-&ir_stream.Tunion.Tstruct.pulse.BitStream[0]);     // the 
             -wait POINTER of 1'st word(word 단위)
                  ir_stream.Tunion.Tstruct.bidxEndWord1=ir_stream.Tunion.Tstruct.bidxEndWord2;                // the wait PO
             -INTER of 1'st word(word 단위)
              
                  ramCode.Custom=cust;
                  ramCode.Data=data1;
              
                  return TRUE;
              }
              #else
2321          
2322          BOOL func_SPECIAL_EA()
2323          {
2324   1        return FALSE;
2325   1      }
2326          #endif
2327          
2328          #if (USE_SPECIAL_0FEH_2 == TRUE)
              BOOL func_SPECIAL_E2()
              {
                return FALSE;
              }
              #else
2334          
2335          BOOL func_SPECIAL_E2()
2336          {
2337   1        return FALSE;
2338   1      }
2339          #endif
2340          
2341          #if (USE_SPECIAL_0FEH_6 == TRUE)
              BOOL func_SPECIAL_E6()
              {
                return FALSE;
              }
              #else
2347          
2348          BOOL func_SPECIAL_E6()
2349          {
2350   1        return FALSE;
2351   1      }
2352          #endif
2353          
2354          unsigned char function_special_Ext_call(void)
2355          {
2356   1        unsigned char rtn = FALSE;
2357   1        
2358   1        switch(ramFormat.strMember.outorder[1]&0x0f)
2359   1        {
2360   2          case 0x2:
2361   2            rtn = func_SPECIAL_E2();  //DATA2_PREIOD
2362   2            break;
2363   2      
2364   2          case 0x3:
2365   2            rtn = func_SPECIAL_E3();  //Metz_Three_Low
2366   2            break;
2367   2      
2368   2          case 0x4:
C51 COMPILER V9.60.0.0   SPECIAL                                                           12/02/2021 14:01:37 PAGE 40  

2369   2            rtn = func_SPECIAL_E4();  //Bang & Olufsen 455KHz
2370   2            break;
2371   2      
2372   2          case 0x5:
2373   2            rtn = func_SPECIAL_E5();  //Three low..
2374   2            break;
2375   2      
2376   2          case 0x6:
2377   2            rtn = func_SPECIAL_E6();  //Shift_Bit
2378   2            break;
2379   2      
2380   2          case 0x8:
2381   2            rtn = func_SPECIAL_E8();  //xmp
2382   2            break;
2383   2      
2384   2          case 0x9:
2385   2            rtn = func_SPECIAL_E9();  //Canal
2386   2            break;
2387   2      
2388   2          case 0x0a:
2389   2            rtn = func_SPECIAL_EA();  ////AMINO_AROSA
2390   2            break;
2391   2      
2392   2          default:
2393   2            rtn = FALSE;
2394   2            break;
2395   2        }
2396   1      
2397   1        return rtn;
2398   1      }
2399          
2400          BOOL func_SPECIAL_FE(void)
2401          {
2402   1        return function_special_Ext_call();
2403   1      }
2404          
2405          #endif  //__SPECIAL_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6831    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      62
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
